# 2.1.基本类型

基本类型包括 Bool，Float 和 Int。它们在语句中可以简单的通过值识别：

- `true` 和 `false` 是 Bool 值
- `1`, `0`, `-1` 和 `0xFF0000` 是 Int 值
- `1.0`, `0.0`, `-1.0`, `1e10` 是 Float 值

在 Haxe 中，基本类型并不是 [类（第2.3节）](/2.类型/2.3.类实例)。它们被实现为 [抽象类型（第2.8节）](/2.类型/2.8.抽象类型)，并和编译器的内部运算符处理绑在一起 —— 像下一节描述的那样处理。



# 2.1.1.数值类型

## Float

> 类型： Float
> 表示一个双精度 IEEE 64 位浮点数

## Int

> 类型： Int
> 表示一个整数

虽然每个 Int 都可以用于一个接受 Float 类型的地方（确切的说，Int 可以赋值到 Float 类型，或者使用 Float 类型统一 Int），而反过来则不行：分配一个 Float 类型到一个 Int 类型可能会丢失精度，是不被隐式的允许的。



# 2.1.2.溢出

出于性能原因，Haxe 编译器不实施任何溢出行为。溢出检查的任务落到目标平台。这里是一些溢出行为的平台特定提示：

C++，Java，C#，Neko，Flash：32位带符号整数有通常的溢出惯例。
 PHP，JS，Flash 8：没有原生的 Int 类型，如果到达浮点数限制（252）则会发生精度的损失。
 另外，`haxe.Int32` 和 `haxe.Int64` 类可以用来确保正确的溢出行为，与平台无关，而额外的计算成本取决于目标平台。



# 2.1.3.数值运算符

下面是Haxe中数值运算符的列表，根据优先级分组：

## 算术运算符

| 运算符 | 操作   | 操作数1 | 操作数2 | 返回值 |
| :----- | :----- | :------ | :------ | :----- |
| ++     | 递增   | Int     | N/A     | Int    |
|        |        | Float   | N/A     | Float  |
| --     | 递减   | Int     | N/A     | Int    |
|        |        | Float   | N/A     | Float  |
| +      | 加法   | Float   | Float   | Float  |
|        |        | Float   | Int     | Float  |
|        |        | Int     | Float   | Float  |
|        |        | Int     | Int     | Int    |
| -      | 减法   | Float   | Float   | Float  |
|        |        | Float   | Int     | Float  |
|        |        | Int     | Float   | Float  |
|        |        | Int     | Int     | Int    |
| *      | 乘法   | Float   | Float   | Float  |
|        |        | Float   | Int     | Float  |
|        |        | Int     | Float   | Float  |
|        |        | Int     | Int     | Int    |
| /      | 除法   | Float   | Float   | Float  |
|        |        | Float   | Int     | Float  |
|        |        | Int     | Float   | Float  |
|        |        | Int     | Int     | Float  |
| %      | 模运算 | Float   | Float   | Float  |
|        |        | Float   | Int     | Float  |
|        |        | Int     | Float   | Float  |
|        |        | Int     | Int     | Int    |

## 比较运算符

| 运算符 | 操作     | 操作数1   | 操作数2   | 返回值 |
| :----- | :------- | :-------- | :-------- | :----- |
| ==     | 相等     | Float/Int | Float/Int | Bool   |
| !=     | 不等     | Float/Int | Float/Int | Bool   |
| <      | 小于     | Float/Int | Float/Int | Bool   |
| <=     | 小于等于 | Float/Int | Float/Int | Bool   |
| >      | 大于     | Float/Int | Float/Int | Bool   |
| >=     | 大于等于 | Float/Int | Float/Int | Bool   |

## 位运算

| 运算符 | 操作         | 操作数1 | 操作数2 | 返回值 |
| :----- | :----------- | :------ | :------ | :----- |
| ~      | 位非         | Int     | N/A     | Int    |
| &      | 位与         | Int     | Int     | Int    |
| \|     | 位或         | Int     | Int     | Int    |
| ^      | 异或         | Int     | Int     | Int    |
| <<     | 左位移       | Int     | Int     | Int    |
| >>     | 右位移       | Int     | Int     | Int    |
| >>>    | 无符号右位移 | Int     | Int     | Int    |

> **枚举的相等性** ：
> 无参数的枚举总是表示同样的值，所以 `==` 。
> 带有参数的枚举可以通过 `a.equals(b)` 的形式比较（是 `Type.enumEquals()` 的简化）。
> **动态类型**：
> 至少涉及一个动态类型值的比较未被指定，视目标平台而定。



# 2.1.4.Bool类型

> **类型**:
> Bool 类型表示一个非 `true` 即 `false` 的值。

Bool 类型的值经常出现在条件中，例如 `if(5.16)` 和 `while(5.14)` 。下面的运算符接受并返回 Bool 类型的值：

- && （和）
- || （或）
- ! （非）

Haxe 保证混合的布尔表达式在运行时从左到右被评估，并且只进行需要的评估。
 例如，表达式 `A && B` 会首先执行 `A` ，然后再执行 `B`，并且只有在 `A` 的结果为 `true` 的时候才继续执行 `B`。同样，表达式 `A || B` 在 `A` 的执行结果为 `true` 的时候不会执行 `B`，因为这时 `B` 的值是无关紧要的。在如下情况这很重要：

```haxe
if (object != null && object.field == 1) { }
```

如果 `object` 为 `null` 的时候访问 `object.field` 会导致一个运行时错误，但是对 `object != null` 的检查则会防止它。



# 2.1.5.Void类型

> **类型**: Void
> `Void` 表示一个类型的缺失。它用来表达一些东西（通常是一个函数）没有值。

`Void` 是类型系统中的一个特殊情况，因为它实际上不是一个类型。它用来表达一个类型的缺失，多数应用于函数参数和返回类型。我们在开始的 “Hello World” 例子中已经见到过 `Void`。

```haxe
class Main {
    static public function main():Void {
        trace("Hello World");
    }
}
```

在 [函数类型（第2.6节）](http:///#) 中将会探索函数类型的详细信息，这里快速预览一下：例子中函数 `main` 的类型为 `Void->Void` ，表示没有参数和返回。Haxe 不允许 `Void` 类型的字段和变量，如果尝试这样声明，它会发出抱怨：

```haxe
// Void类型的参数和变量是不被允许的 
var x:Void;
```

**注：在实际编写测试代码的时候，尝试在类的 `main` 函数内定义 `var x:Void;` 并未报错，而作为类字段进行定义则不能编译，提示 “Fields of type Void are not allowed”。【环境：Haxe 3.3.0-rc.1】**

